const name = prompt('Введите имя:', '');
Number(var) - преобразование к числу; String(var) - к строке; Boolean(var) - к лог.;
isNaN(parseFloat(переменная)) || !isFinite(переменная) - проверка, введено ли пользователем число;
Локал. переменные - объявлены внутри функции, глобал - объявлены вне;
В функции можно указать не все параметры или не указать их. Обращатьяс к ним можно через arguments[i].
typeof - определяет тип переменной - alert(typeof n);

======================================== HTML-теги ============================================
<input type='text'/'number' defaultValue={name}></input>

<form>  //ПЕРЕКЛЮЧАТЕЛИ, МОЖНО ВЫБРАТЬ ТОЛЬКО ОДИН
  <p>
    <input  type="radio" value="w"> Ж <br>
    <input  type="radio" value="m"> M
  </p>
</form>

<form>  //ПЕРЕКЛЮЧАТЕЛИ, МОЖНО ВЫБРАТЬ ВСЕ
  <input type="checkbox" name="language" value="0"> Python<br>
  <input type="checkbox" name="language" value="1" checked> JavaScript<br>
  <input type="checkbox" name="language" value="2" checked> C#<br>
  <input type="checkbox" name="language" value="3"> PHP
</form>

<select name="language">  //ВЫБОР
 <option value="0"> JavaScript </option>
 <option value="1" selected> Python </option>
 <option value="2"> PHP </option>
</select>


ПЕРЕД КАЖДОЙ ПЕРЕМЕННОЙ, МАССИВОМ, ФУНКЦИЕЙ СТАВИТЬ CONST/LET!!1!1!1!!!1

===================================== СТИЛИ CSS ==============================================
ТЕМ, ЧТО СО ЗНАКОМ '=' - МОЖНО ТАК И ПРОПИСЫВАТЬ ВНУТРИ HTML-ТЕГА, ТЕ ЖЕ ЧТО С ':' - ТОЛЬКО ВНУТРИ style={{}}
В JSX ВСЁ ТО, ЧТО С '-', ЗАПИСЫВАЕТСЯ БЕЗ НЕЁ И С ЗАГЛАВНОЙ БУКВОЙ СЛЕДУЮЩЕГО СЛОВА: textAlign
style={{display: 'none'}}

color: red - цвет;
font-size: 10px - размер шрифта;
font-weight: bold - выделение текста;
display: 'none' - отображение, в данном случае элемент скроется;
text-align: center - выравнивание текста;
background-color: red - цвет фона;
width: 100px - ширина;

border-width: 100px - ширина границы;
border-color: green - цвет границы;
border-style: solid - стиль линии для границы;

margin: 10px - отступ от текущего элемента до границы охватывающего;
padding: 10px - отступ от границы элемента до его содержимого;


align='center' - размещение по-середине



====================================== СТРОКИ =================================================
Сложение строк: str1 + str2;
Длина определяется методом length: str.length;
Обращение к элементу строки: str.charAt(0) или str[0]; изменить один элемент строки нельзя;
toLowerCase() и toUpperCase() - преобразует все буквы к маленьким (строчным) и большим (прописным) соответв.;
str.trim() - удаляет пробелы с начала и конца строки; str.trimRight() - удаляет с конца; str.trimLeft() - удаляет с начала;

===================================== МАССИВЫ =================================================
let arr = [] - создание пустого массива;
let arrGoods = ['карандаш', 'ручка', 'тетрадь'] - создание массива с изначальными позициями;
for (let i in arr) - цикл перебора всех элементов массива;
forEach() - метод массива, arr.forEach( function(elem, index, arr) {}), 1-й парам - эл-т массива, 2-й - номер в массиве, 3-й - сам массив;
arr.join() - преобраз. массива в строку;
arr.push(элемент) - добавить элемент (ССЫЛКА) в конец; arr.unshift(элемент) - добавить в начало; можно добавить несколько элементов (через запятую);
arr.pop() - удаление посл. элемента, arr.shift() - удаление первого эл-та;
splice(позиция[, кол_эл-тов, новЭл1, ... , новЭлN]) - вставка/удаление/замена элементов;
arr.includes(значение, [индекс]) - поиск значения в массиве, возвр. лог. значение; использует строгое сравнение;
arr.indexOf(значение, [индекс]) - возвр. индекс 1-о вхождения элемента, если он находится в массиве, иначе -1. Можно указать, с какого индекса массива начать поиск;
arr.lastIndexOf(значение, [индекс]) - тоже самое, но возвращает индекс last элемента;
arr.find() - требует функцию в качестве параметра, которая может иметь 1-3 параметра для поиска элемента в массиве. Возвращает 1-е вхождение. arr.find(function(elem, index) {return elem >= 13 && elem <= 20 && index > 2});
arr.filter() - тоже самое, но возвращает все элементы, удовл. условию, в виде массива;
arr.sort() - сортирует содержимое, причём элементы рассматриваются как строки; arr.sort(function compare(a, b) { return Number(a) - Number(b) })
arr.reverse() - переставляет эл-ты массива в обратном порядке;
newArr = [].concat(arr1, arr2) - слияние 2 массивов;
Многомерные массивы: let matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ];
arr.slice(start,end) - разделяет массив по индексам. end можно не указывать; 
arr.join() - преобразовывает массив в строку;

===================================== DOM-МОДЕЛЬ ==============================================
document.write() - что-то вписать в документ;
ЭЛЕМЕНТ - теги, УЗЕЛ - помимо тегов текст, комменты и т.д.;
parentNode или parentElement - родитель элемента;
firstChild и lastChild - доступ к 1-у и last дочернему узлу;
firstElementChild и lastElementChild - тоже самое, но эл-ты;
previousSibling и nextSibling - доступ к узлам любого типа слева и справа от данного;
PreviousElementSibling и nextElementSibling - тоже самое, но эл-ты;
ParenNode или ParentElement - родительский узел или эл-ты соответственно;
children (эл-ты) или childNodes (узлы) - коллекция детей элемента, elements - дети form;
Поиск элемента в дереве: getElementById (id), getElementByName (name), getElementsByTagName (тег), getElementsByClassName (класс). Последние 2 возвращают КОЛЛЕКЦИЮ элементов, а не один элемент;
СВ-ВА УЗЛОВ: NodeType - тип узла, nodeName - название тега, className - название класса, style - описание притеговых стилей, innerHTML - внутр. содержимое, outerHTML - содержание целиком, textContent - текст без тегов, hidden - видимость эл-та;
КЛАССЫ CSS: className - получить/задать класс, classList.contains(class) - возвр. true/false в завис. от того, есть ли у эл-та класс с именем class, classList.add(class) - добавляет класс class, classList.remove(class) - удаляет класс class, classList.toggle(class) - если есть class, то удаляет, иначе добавляет, classList - коллекция классов эл-та;
СОЗДАНИЕ И ВСТАВКА ЭТ-ТОВ: document.createElement(tag) - создаёт эл-т, document.createTextNode(text) - создаёт текст. узел, node.cloneNode(true/false) - создаёт копию node, если true то с детьми, иначе без, parent.appendChild(node) - добавить эл-т node в конец детей эл-та parent, parent.insertBefore(node,nextSibling) - вставить node в коллекцию детей эл-та parent перед nextSibling;
ВСТАВКА ЭЛ-ТОВ: node.append(nodes или strings) - добавить узлы/строки в конец node, node.prepend(nodes или strings) - вставить узлы/строки до node, node.before(nodes или strings) - вставляет узлы/строки до node, node.after(nodes или strings) - вставляет узлы/строки после node, node.replaceWith(nodes или strings) - замена node заданными узлами/строками; 
УДАЛЕНИЕ ЭЛ-ТОВ: parent.removeChild(node) - удаляет node из parent, parent.replaceChild(newNode, node) - удаляет node и вставляет вместо него newNode, node.remove() - напрямую удаляет эл-т node;

=================================== СОБЫТИЯ ===================================================
МЫШЬ: onmousedown - кнопка нажата над эл-том, onmouseup - отпущена над элементом, onmouseover - мышь появилась над эл-том, onmouseout - мышь ушла с эл-та, onmousemove - каждое движение мыши над эл-тов генерирует это событие, onclick - при клике, oncontenxtmenu - клик ПКМ, ondblclick - двойной клик;
ДЛЯ ONCLICK: event.which = 1, event.which = 2, event.which = 3;
КЛАВИАТУРА: onkeydown - нажатие клавиши, onkeyup - отпуск клавиши, onkeypress - нажатие символьной клавиши;
УКАЗАТЬ КАКАЯ ИМЕННО КЛАВИША: event: event.KeyCode;
ЗАГРУЗКА: onDOMContentLoaded - браузер полн. загрузил HTML и построил DOM-дерево, onload - ген., когда браузер загрузил все ресурсы, onbeforeunload/ onunload - ген. при уходе со страницы;
ДЛЯ ФОРМЫ: onclick - клик мыши по эл-ту формы, onchange - изменение значения, oninput - каждое изменение значения, oncut/oncopy/onpaste - действия по cut/copy/paste, onblur - потеря элемента фокуса, onfocus - получение фокуса эл-том;
СОБЫТИЯ В ВИДЕ HTML-ТЕГА: <тег событие="обработчик события"...>
ИСПОЛЬЗУЯ DOM-СВОЙСТВО:
element.событие = function() {
  операторы
}
EVENTLISTENER: element.addEventListener(event, handler, [options]);

================================ АССОЦИАЦ. МАССИВЫ ============================================
let имя = {};
let имя = {
  ключ1: знач1,
  ключ2: знач2,
  ...
};
Обращение: good.name или good['name'];
Можно создавать новые свойства: good.cost = 3.14 или good['cost'] = 3.14;
Object.keys(имя) - возвр. массив ключей, Object.values(имя) - массив значений, Object.entries(имя) - массив пар [ключ, знач.];
ЦИКЛ ЧТОБЫ ПРОСМОТРЕТЬ КЛЮЧИ И ИХ ЗНАЧЕНИЯ:
for (let ключ in объект) {
  ...
};
ПРОВЕРИТЬ НАЛИЧИЕ КЛЮЧА В АС. МАССИВЕ: if (ключ in объект);
УДАЛЕНИЕ СВ-В: delete объект.ключ:
КАК ЭЛЕМЕНТ МАССИВА:
let arrGoods = [
  {
    name: "ручка",
    count: 100
  },
  {
    name: "карандаш",
    count: 120
  }
];
МАССИВ КАК СВ-ВО АС. МАССИВА: 
let objGoods = {
  "ручка": [100, 50.60],
  "карандаш": [120, 30.00]
}
У ОБЪЕКТОВ ОДНО ИЗ СВОЙСТВ МОЖЕТ БЫТЬ МЕТОДОМ:
let good = {
  ...
  getAllPrice : function () {
 return this.price * this.amount
 }
};

=============================== Функц. программирование =======================================
Иммутабельное добавление: 
let copy = Object.assign([], arr)
copy.push(6)
let res = copy ИЛИ let res = [...arr, 6];
const x = a > 0 ? 1 : -1;

копия массива создаётся ВОТ ТАК: const arr2 = [...arr]

Stack - список элементов, по принципу последний пришёл - первым вышел.
const stack = [...new Stack]
stack = stack.push( 2, 1, 0)
stack.size;
stack.get() //2
stack.get(1) //1
stack.get(2) //0
let stackNew = stack.pop() // [1, 0]

Set - множество для уникальных значений.
arr = [1, 1, 2, 2, 3, 3]
const map = [...new Set(arr)] //получаем массив с только уникальными значениями;


arr.map((item, index, array) => item*2) - перебор всех эл-тов массива и выоплнения какой-то функции для них. item - элемент, index - индекс элемента, array - сам массив (arr);

array.filter() - создаёт массив из элементов из исходного (array), удовлетворяющих какому-то условию.
array.filter.filter((elem, ind. arr) => {
    if (arr.indexOf(elem, ind+1) == -1) return true
    else return false
})
elem - элемент массива, ind - индекс, arr - массив;

array.reduce() - вычисление на основе массива какого-то единого значения.
array.reduce((product, item) => {
  return product * item
}, 1)
product - аккумулятор (накапливает значение), item - очередной элемент, 1 в самом конце - начальное значение аккумулятора;


==================================== D3 =======================================================
d3.select("имя") - возвр. первый соответствующий элемент, d3.selectAll("имя") - возвращает все соответ. элементы;
d3.selectAll("div").selectChild("ol"), d3.selectAll("div.menu").select("li");
selectChild("имя") - выбирает детей выбранного узла;
Операторы позв. установить или получить значение: attr() - атрибута, style() - стиля элемента, text() - текст. содерж., html() - html-кода эл-та;
.node() или .nodes() - возвращает массив из ненулевых узлов;
.append("эл-т") - добавляет новый эл-т, insert("эл-т", "эл-т перед кот. вставить") - добавляет новый эл-т перед заданным, remove("эл-т") - удаляет эл-т;
d3.SelectAll("p").attr("class", "red") - всем абзацам присв. класс red;
Метод data() устанавливает связь между элементами HTML и элементами;
d3.selectAll("li").data(mas).text(d => d);
enter() - если элементов HTML меньше, чем эл-тов data, то что делаем;
d3.select("ul:nth-child(3)").selectAll("li").data(mas3).enter().append("li");
exit() - если наоборот, эл-тов HTML больше, то что делать с незаполнеными;
:nth-child(n) - выбрать n-й элемент; 
d3.min(data) - мин. значение массива data, d3.max(data) - макс., d3.extent(data) - мин. и макс. знач. в виде массива из 2 эл-тов, d3.sum(data) - сумма всех эл-тов, d3.median(data) - медиана, d3.mean(data) - среднее знач.;

d3.group() - возр. сгрупп. по нек. ключу данные;
d3.group(books, d => d.author);

.filter() - фильтрация по каким-то данным;
.filter(d => !(d.author == "Толстой Л.Н.")).style("display", "none"); 
.on('событие', function(){
       d3.select(this)
}) - обработчик событий через d3;
.sort - сортировка элементов, на вход принимает функцию;
ScaleTime - сопоставление даты, ScaleLog - сопоставление списка;

=================================== D3 №2 =====================================================
Общие для всех стили: "stroke" (цвет) и "stroke-width" (цифра), fill (цвет) (для замкнутых фигур);
line - создание линии, у неё 4 координаты: x1, x2, y1, y2;
rect - прямоугольник, x и y - координаты левого крайнего угла, width и height - ширина и высота, rx - скругление углов, стиль fill - цвет внутри, также есть stroke и stroke-width;
circle - круг, cx и cy - координаты центра, r - радиус;
polygon - многоугольник, point - массив точек, last соединяется с first: .attr("points", "25,25 25,195 282,195");
delay - период задержки анимации;
События для анимации - start (начало), end (конец), interruput (прерывание), cancel (отмена);
path - создание пути, отображает любые примитивы с заполнением цветом или без:
let data = [
  {x: 80, y: 270}, {x: 110, y: 250}, {x: 140, y: 260}
];
Функция, строющая путь:
let line = d3.line()
             .x(d => d.x)
             .y(d => d.y);
g - создание групп элементов;

d3.svg.axis() - метод для создания осей координат

================================ Основы React ================================================
Создать проект:
npx create-react-app my-app
cd my-app
npm start;

ПУТЬ ДЛЯ ПК: cd Desktop, cd WebProg, cd SEM_2 LAB 5, cd PRAKTIKA;

Примеры JSX: const element = (
<h2>
  Привет, мир
</h2>
)
Если значение в одной строке, то можно без скобок. Обязан быть один родительский элемент;
Переменные и функции заключатся в фигурные скобки;

Названия React-компонентов записывать с БОЛЬШОЙ БУКВЫ, чтобы отличить их от тего HTML;
Компоненты:
function Hello = (props) => <h2>Привет, {props.name}!</h2>
const element = <Hello name='Алина' />
root.render(element)
В root.render() передаётся React-элемент <Hello name='Алина' />, элемент вызывает компонент Hello с пропсом {name: 'Алина'}; 
Можно определить значения свойств по умолчанию на случай, если они пропущены с помощью defaultProps: Hello.defaultProps = {name: "Иван"} (для класса)
В компоненте-классе ко всем внутренним методам и props'ам нужно обращаться с помощью this;

Чтобы обернуть несколько HTML-тегов, можно прописать их между <></>;

Компонент никогда не должен что-то записывать в свои пропсы! Они только для чтения;

Пример кнопки:
const Knopka = (props) => {
  const giveM = () => alert(props.mess)
  return <button onClick={giveM}>Я КНОПКА</button>
}
const el = <Knopka mess='PUTIN IS GOD'></Knopka>;

Вариант кнопки, где обработчику событий передаётся переменная:
const Knopka = (props) => {
  function giveM(name) {
     console.log(name)
     alert('Привет, '+name+'!')
  }   
  return <button onClick={() => giveM(props.mess)}>Я КНОПКА</button>
}
const el = <Knopka mess='PUTIN IS GOD'></Knopka>

Пример компонента-класса:
class Komp extends React.Component {

  state = {   //ОБЪЯВЛЕНИЕ СОСТОЯНИЙ. ДАЛЬШЕ ОБРАЩАТЬСЯ С ПОМОЩЬЮ this.setState()
    number: this.props.num
  }

  clc = () => {
    this.setState({number: this.state.number+1})
  }

  render() {
    return <div>
      <p>{this.state.number}</p>
      <button onClick={this.clc}>Клик</button>
    </div>  
  }
}

КЛАСС-КНОПКА:
class ButtonClass extends React.Component { 

  constructor(props) {
    super(props);
    this.press = this.press.bind(this) 
}

  press() {
    alert('Привет!')  
  }

  render() {
    return <button onClick={this.press}>Click</button>
  }  
} 

Менять состояние можно только с помощью метода setState()

Если передать событию 'event', то можно вывести его и узнать о событии;

Math.round(Math.random() * 100) - вызвать случайное число;

================================ Хуки ========================================================
Чтобы добавить какой-либо хук, нужно в начале прописать: import { НАЗВАНИЕ ХУКА } from 'react'

useState() - позволяет определить состояние компонента; единственный аргумент определяет начальное значение переменной состояния; возвращает массив из двух объектов - значение состояния и функцию для обновления этого значения. Пример использования:
const [переменная, функция] = React.useState(начальное_значение);

useEffect() - позволяет управлять различными сопутствующими действиями в функц. компоненте: извлечение данных, ручное изменение структуры DOM, использование таймеров, логгирование и т.д.
Получает на вход 2 аргумента (последний не обязателен): effect - функция, внутри которой происходит работа с обновлёнными данными, 2-й же - массив зависимостей: когда любое значение из него изменится, то вызовется effect. Если массив не указан, то effect вызывается при каждом рендеринге, если массив пустой - effect вызывается только один раз
React.useEffect(() => {
  --ЧТО-ТО ТУТ НАПИСАНО КРЧ--
}, [пер1, пер2, ...])

useContext() - способ для дочернего компонента получить доступ к значению в родительском компоненте;
1. Создавать компонент-посредник: const TableContext = React.createContext();
2. В родительском компоненте, в момент обращения к дочернему компоненту подключить провайдер и передать данные в контекст через пропс value: 
      <TableContext.Provider value={{
        dataTable: dataTable,
        dataWithoutSort: dataWithoutSort,
        updateDataTable: updateDataTable,
        setDataWithoutSort: setDataWithoutSort,
        currData: consoles
      }}>  
        <Sort />
      </TableContext.Provider>;
3. Получить данные контекста в дочернем компоненте.
const context = React.useContext(TableContext);

useRef - позволяет взаимодействовать с DOM. ref - это атрибут компонента, значением которого должен быть объект, созданный с помощью React.useRef(). Свойство current этого объекта даёт доступ к элементу DOM.
Объявить ref-объект: const chartRef = useRef(null);
Привязать к HTML-тегу: <p ref={chartRef}>ыыы</p>;
chartRef.current.innerHTML - получение свойства innerHTML привязанного тега (в этом случае "ыыы");
chartRef.current.focus() - установить курсор на элемент;

useMemo - оптимизация вычислений
const peremen = useMemo(() => {
  //вычисления
  return ...;
}, [зависимости])



const int = setInterval(() => {
   alert('1')
}, 100000) - функция, задающая интервал;

======================================== TypeScript =========================================
ТИПЫ: NUMBER (числа), STRING (строки), BOOLEAN (да или нет), LITERAL (?), NULL (отсутствие значения) и UNDEFINED (не присвоено значение), ANY (отключение проверки типов), UNKNOWN (надмножество всех доступных типов), VOID (указание на отсутствие значения, полезно в функциях);

Массивы также являются строго типизированными: let list: string[] = ["red", "green", "blue"] или let list: Array<string> = ["red", "green", "blue"]
Если массив содержит строки, то в будущем сможет работать только со строками;

ReadonlyArray - массив, чьи значения нельзя изменять, добавлять новые или удалять уже имеющиеся элементы: const people: ReadonlyArray<string> = [...] или const people: readonly string[] = [...];

Декомпозиция массивов: const people: string[] = ["Иван", "Ольга", "Семён"]
const [first, second, third] = people
const [first, ...rest] = people;

Кортежи - набор элементов, в которых, в отличие от массив, могут быть элементы разных типов:
let user: [string, number, boolean?] - 1-й элемент строка, 2-й - число, 3-й - условие (он необязателен);
let math: [string, ...number[]] = ['Math', 5, 4, 5, 4, 4];
Кортежи тоже могут быть только для чтения, их можно декомпозировать. Объявляется это так же, как и в случае с массивами;

Объект объявляется так же, как и в JS, но в силу строготипизированности TypeScript у него должно быть больше одного атрибута (ключа):
let person = { name: "Иван", age: 20 };
Можно записать вот так: let person: { name: string; age: number } = { name: "Алина", age: 23 };

function sqr(value: number): void {
   console.log('1')
}

===================================== TypeScript и React ======================================



 










