const name = prompt('Введите имя:', '');
Number(var) - преобразование к числу; String(var) - к строке; Boolean(var) - к лог.;
isNaN(parseFloat(переменная)) || !isFinite(переменная) - проверка, введено ли пользователем число;
Локал. переменные - объявлены внутри функции, глобал - объявлены вне;
В функции можно указать не все параметры или не указать их. Обращатьяс к ним можно через arguments[i].
typeof - определяет тип переменной - alert(typeof n);

====================================== СТРОКИ =================================================
Сложение строк: str1 + str2;
Длина определяется методом length: str.length;
Обращение к элементу строки: str.charAt(0) или str[0]; изменить один элемент строки нельзя;
toLowerCase() и toUpperCase() - преобразует все буквы к маленьким (строчным) и большим (прописным) соответв.;
str.trim() - удаляет пробелы с начала и конца строки; str.trimRight() - удаляет с конца; str.trimLeft() - удаляет с начала;

===================================== МАССИВЫ =================================================
let arr = [] - создание пустого массива;
let arrGoods = ['карандаш', 'ручка', 'тетрадь'] - создание массива с изначальными позициями;
for (let i in arr) - цикл перебора всех элементов массива;
forEach() - метод массива, arr.forEach( function(elem, index) {}), 1-й парам - эл-т массива, 2-й - номер в массиве, 3-й - сам массив;
arr.join() - преобраз. массива в строку;
arr.push(элемент) - добавить элемент (ССЫЛКА) в конец; arr.unshift(элемент) - добавить в начало; можно добавить несколько элементов (через запятую);
arr.pop() - удаление посл. элемента, arr.shift() - удаление первого эл-та;
splice(позиция[, кол_эл-тов, новЭл1, ... , новЭлN]) - вставка/удаление/замена элементов;
arr.includes(значение, [индекс]) - поиск значения в массиве, возвр. лог. значение; использует строгое сравнение;
arr.indexOf(значение, [индекс]) - возвр. индекс 1-о вхождения элемента, если он находится в массиве, иначе -1. Можно указать, с какого индекса массива начать поиск;
arr.lastIndexOf(значение, [индекс]) - тоже самое, но возвращает индекс last элемента;
arr.find() - требует функцию в качестве параметра, которая может иметь 1-3 параметра для поиска элемента в массиве. Возвращает 1-е вхождение. arr.find(function(elem, index) {return elem >= 13 && elem <= 20 && index > 2});
arr.filter() - тоже самое, но возвращает все элементы, удовл. условию, в виде массива;
arr.sort() - сортирует содержимое, причём элементы рассматриваются как строки; arr.sort(function compare(a, b) { return Number(a) - Number(b) })
arr.reverse() - переставляет эл-ты массива в обратном порядке;
newArr = [].concat(arr1, arr2) - слияние 2 массивов;
Многомерные массивы: let matrix = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ];
arr.slice(start,end) - разделяет массив по индексам. end можно не указывать; 
arr.join() - преобразовывает массив в строку;

===================================== DOM-МОДЕЛЬ ==============================================
document.write() - что-то вписать в документ;
ЭЛЕМЕНТ - теги, УЗЕЛ - помимо тегов текст, комменты и т.д.;
parentNode или parentElement - родитель элемента;
firstChild и lastChild - доступ к 1-у и last дочернему узлу;
firstElementChild и lastElementChild - тоже самое, но эл-ты;
previousSibling и nextSibling - доступ к узлам любого типа слева и справа от данного;
PreviousElementSibling и nextElementSibling - тоже самое, но эл-ты;
ParenNode или ParentElement - родительский узел или эл-ты соответственно;
children (эл-ты) или childNodes (узлы) - коллекция детей элемента, elements - дети form;
Поиск элемента в дереве: getElementById (id), getElementByName (name), getElementsByTagName (тег), getElementsByClassName (класс). Последние 2 возвращают КОЛЛЕКЦИЮ элементов, а не один элемент;
СВ-ВА УЗЛОВ: NodeType - тип узла, nodeName - название тега, className - название класса, style - описание притеговых стилей, innerHTML - внутр. содержимое, outerHTML - содержание целиком, textContent - текст без тегов, hidden - видимость эл-та;
КЛАССЫ CSS: className - получить/задать класс, classList.contains(class) - возвр. true/false в завис. от того, есть ли у эл-та класс с именем class, classList.add(class) - добавляет класс class, classList.remove(class) - удаляет класс class, classList.toggle(class) - если есть class, то удаляет, иначе добавляет, classList - коллекция классов эл-та;
СОЗДАНИЕ И ВСТАВКА ЭТ-ТОВ: document.createElement(tag) - создаёт эл-т, document.createTextNode(text) - создаёт текст. узел, node.cloneNode(true/false) - создаёт копию node, если true то с детьми, иначе без, parent.appendChild(node) - добавить эл-т node в конец детей эл-та parent, parent.insertBefore(node,nextSibling) - вставить node в коллекцию детей эл-та parent перед nextSibling;
ВСТАВКА ЭЛ-ТОВ: node.append(nodes или strings) - добавить узлы/строки в конец node, node.prepend(nodes или strings) - вставить узлы/строки до node, node.before(nodes или strings) - вставляет узлы/строки до node, node.after(nodes или strings) - вставляет узлы/строки после node, node.replaceWith(nodes или strings) - замена node заданными узлами/строками; 
УДАЛЕНИЕ ЭЛ-ТОВ: parent.removeChild(node) - удаляет node из parent, parent.replaceChild(newNode, node) - удаляет node и вставляет вместо него newNode, node.remove() - напрямую удаляет эл-т node;

=================================== СОБЫТИЯ ===================================================
МЫШЬ: onmousedown - кнопка нажата над эл-том, onmouseup - отпущена над элементом, onmouseover - мышь появилась над эл-том, onmouseout - мышь ушла с эл-та, onmousemove - каждое движение мыши над эл-тов генерирует это событие, onclick - при клике, oncontenxtmenu - клик ПКМ, ondblclick - двойной клик;
ДЛЯ ONCLICK: event.which = 1, event.which = 2, event.which = 3;
КЛАВИАТУРА: onkeydown - нажатие клавиши, onkeyup - отпуск клавиши, onkeypress - нажатие символьной клавиши;
УКАЗАТЬ КАКАЯ ИМЕННО КЛАВИША: event: event.KeyCode;
ЗАГРУЗКА: onDOMContentLoaded - браузер полн. загрузил HTML и построил DOM-дерево, onload - ген., когда браузер загрузил все ресурсы, onbeforeunload/ onunload - ген. при уходе со страницы;
ДЛЯ ФОРМЫ: onclick - клик мыши по эл-ту формы, onchange - изменение значения, oninput - каждое изменение значения, oncut/oncopy/onpaste - действия по cut/copy/paste, onblur - потеря элемента фокуса, onfocus - получение фокуса эл-том;
СОБЫТИЯ В ВИДЕ HTML-ТЕГА: <тег событие="обработчик события"...>
ИСПОЛЬЗУЯ DOM-СВОЙСТВО:
element.событие = function() {
  операторы
}
EVENTLISTENER: element.addEventListener(event, handler, [options]);

================================ АССОЦИАЦ. МАССИВЫ ============================================
let имя = {};
let имя = {
  ключ1: знач1,
  ключ2: знач2,
  ...
};
Обращение: good.name или good['name'];
Можно создавать новые свойства: good.cost = 3.14 или good['cost'] = 3.14;
Object.keys(имя) - возвр. массив ключей, Object.values(имя) - массив значений, Object.entries(имя) - массив пар [ключ, знач.];
ЦИКЛ ЧТОБЫ ПРОСМОТРЕТЬ КЛЮЧИ И ИХ ЗНАЧЕНИЯ:
for (let ключ in объект) {
  ...
};
ПРОВЕРИТЬ НАЛИЧИЕ КЛЮЧА В АС. МАССИВЕ: if (ключ in объект);
УДАЛЕНИЕ СВ-В: delete объект.ключ:
КАК ЭЛЕМЕНТ МАССИВА:
let arrGoods = [
  {
    name: "ручка",
    count: 100
  },
  {
    name: "карандаш",
    count: 120
  }
];
МАССИВ КАК СВ-ВО АС. МАССИВА: 
let objGoods = {
  "ручка": [100, 50.60],
  "карандаш": [120, 30.00]
}
У ОБЪЕКТОВ ОДНО ИЗ СВОЙСТВ МОЖЕТ БЫТЬ МЕТОДОМ:
let good = {
  ...
  getAllPrice : function () {
 return this.price * this.amount
 }
};

=============================== Функц. программирование =======================================
arr.map((item) => item*2) - перебор всех эл-тов массива и выоплнения какой-то функции для них;
Иммутабельное добавление: 
let copy = Object.assign([], arr)
copy.push(6)
let res = copy ИЛИ let res = [...arr, 6];
const x = a > 0 ? 1 : -1;
const res = arr.reduce((product, item) =>
  return product * item
}, 1) - возвращает из массива какое-то одно значение;


==================================== D3 =======================================================
d3.select("имя") - возвр. первый соответствующий элемент, d3.selectAll("имя") - возвращает все соответ. элементы;
d3.selectAll("div").selectChild("ol"), d3.selectAll("div.menu").select("li");
selectChild("имя") - выбирает детей выбранного узла;
Операторы позв. установить или получить значение: attr() - атрибута, style() - стиля элемента, text() - текст. содерж., html() - html-кода эл-та;
.node() или .nodes() - возвращает массив из ненулевых узлов;
.append("эл-т") - добавляет новый эл-т, insert("эл-т", "эл-т перед кот. вставить") - добавляет новый эл-т перед заданным, remove("эл-т") - удаляет эл-т;
d3.SelectAll("p").attr("class", "red") - всем абзацам присв. класс red;
Метод data() устанавливает связь между элементами HTML и элементами;
d3.selectAll("li").data(mas).text(d => d);
enter() - если элементов HTML меньше, чем эл-тов data, то что делаем;
d3.select("ul:nth-child(3)").selectAll("li").data(mas3).enter().append("li");
exit() - если наоборот, эл-тов HTML больше, то что делать с незаполнеными;
:nth-child(n) - выбрать n-й элемент; 
d3.min(data) - мин. значение массива data, d3.max(data) - макс., d3.extent(data) - мин. и макс. знач. в виде массива из 2 эл-тов, d3.sum(data) - сумма всех эл-тов, d3.median(data) - медиана, d3.mean(data) - среднее знач.;
d3.group() - возр. сгрупп. по нек. ключу данные;
d3.group(books, d => d.author);
.filter() - фильтрация по каким-то данным;
.filter(d => !(d.author == "Толстой Л.Н.")).style("display", "none"); 
.on('событие', function(){
       d3.select(this)
}) - обработчик событий через d3;
.sort - сортировка элементов, на вход принимает функцию;
ScaleTime - сопоставление даты, ScaleLog - сопоставление списка;

=================================== D3 №2 =====================================================
Общие для всех стили: "stroke" (цвет) и "stroke-width" (цифра), fill (цвет) (для замкнутых фигур);
line - создание линии, у неё 4 координаты: x1, x2, y1, y2;
rect - прямоугольник, x и y - координаты левого крайнего угла, width и height - ширина и высота, rx - скругление углов, стиль fill - цвет внутри, также есть stroke и stroke-width;
circle - круг, cx и cy - координаты центра, r - радиус;
polygon - многоугольник, point - массив точек, last соединяется с first: .attr("points", "25,25 25,195 282,195");
delay - период задержки анимации;
События для анимации - start (начало), end (конец), interruput (прерывание), cancel (отмена);
path - создание пути, отображает любые примитивы с заполнением цветом или без:
let data = [
  {x: 80, y: 270}, {x: 110, y: 250}, {x: 140, y: 260}
];
Функция, строющая путь:
let line = d3.line()
             .x(d => d.x)
             .y(d => d.y);
g - создание групп элементов;

d3.svg.axis() - метод для создания осей координат

================================ Основы React ================================================
Создать проект:
npx create-react-app my-app
cd my-app
npm start;

ПУТЬ ДЛЯ ПК: cd Desktop, cd WebProg, cd SEM_2 LAB 5, cd PRAKTIKA;

Примеры JSX: const element = (
<h2>
  Привет, мир
</h2>
)
Если значение в одной строке, то можно без скобок. Обязан быть один родительский элемент;
Переменные и функции заключатся в фигурные скобки;

Названия React-компонентов записывать с БОЛЬШОЙ БУКВЫ, чтобы отличить их от тего HTML;
Компоненты:
function Hello = (props) => <h2>Привет, {props.name}!</h2>
const element = <Hello name='Алина' />
root.render(element)
В root.render() передаётся React-элемент <Hello name='Алина' />, элемент вызывает компонент Hello с пропсом {name: 'Алина'}; 
Можно определить значения свойств по умолчанию на случай, если они пропущены с помощью defaultProps: Hello.defaultProps = {name: "Иван"} (для класса)
В компоненте-классе ко всем внутренним методам и props'ам нужно обращаться с помощью this;

Чтобы обернуть несколько HTML-тегов, можно прописать их между <></>;

Компонент никогда не должен что-то записывать в свои пропсы! Они только для чтения;

Пример кнопки:
const Knopka = (props) => {
  const giveM = () => alert(props.mess)
  return <button onClick={giveM}>Я КНОПКА</button>
}
const el = <Knopka mess='PUTIN IS GOD'></Knopka>;

Вариант кнопки, где обработчику событий передаётся переменная:
const Knopka = (props) => {
  function giveM(name) {
     console.log(name)
     alert('Привет, '+name+'!')
  }   
  return <button onClick={() => giveM(props.mess)}>Я КНОПКА</button>
}
const el = <Knopka mess='PUTIN IS GOD'></Knopka>

Если передать событию 'event', то можно вывести его и узнать о событии;

Math.round(Math.random() * 100) - вызвать случайное число;

================================ Хуки ========================================================
useState() - позволяет определить состояение компонента; единственный аргумент определяет начальное значение переменной состояния; возвращает массив из двух объектов - значение состояния и функцию для обновления этого значения. Пример использования:
const [переменная, функция] = React.useState(начальное_значение);

useEffect() - позволяет управлять различными сопутствующими действиями в функц. компоненте: извлечение данных, ручное изменение структуры DOM, использование таймеров, логгирование и т.д.
Получает на вход 2 аргумента (последний не обязателен): effect - функция, внутри которой происходит работа с обновлёнными данными, массив зависимостей





 










